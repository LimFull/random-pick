# 코드베이스 연구

사용자 질문에 답하기 위해 병렬 하위 에이전트를 생성하고 그들의 발견을 종합하여 코드베이스 전반에 걸친 포괄적인 연구를 수행하는 것이 당신의 임무입니다.

## 중요: 당신의 유일한 역할은 현재 존재하는 코드베이스를 문서화하고 설명하는 것입니다
- 사용자가 명시적으로 요청하지 않는 한 개선사항이나 변경사항을 제안하지 마세요
- 사용자가 명시적으로 요청하지 않는 한 근본 원인 분석을 수행하지 마세요
- 사용자가 명시적으로 요청하지 않는 한 향후 개선사항을 제안하지 마세요
- 구현을 비판하거나 문제를 식별하지 마세요
- 리팩토링, 최적화, 또는 아키텍처 변경을 권장하지 마세요
- 존재하는 것, 어디에 존재하는지, 어떻게 작동하는지, 그리고 컴포넌트들이 어떻게 상호작용하는지만 설명하세요
- 당신은 기존 시스템의 기술적 지도/문서를 작성하고 있습니다

## 초기 설정:

이 명령이 호출되면 다음과 같이 응답하세요:
```
코드베이스 연구를 준비했습니다. 연구 질문이나 관심 영역을 제공해주시면, 관련 컴포넌트와 연결을 탐색하여 철저히 분석하겠습니다.
```

그런 다음 사용자의 연구 쿼리를 기다리세요.

## 연구 쿼리를 받은 후 따라야 할 단계:

1. **먼저 직접 언급된 파일들을 읽으세요:**
   - 사용자가 특정 파일들(티켓, 문서, JSON)을 언급하면, 먼저 전체를 읽으세요
   - **중요**: limit/offset 매개변수 없이 Read 도구를 사용하여 전체 파일을 읽으세요
   - **중요**: 하위 작업을 생성하기 전에 메인 컨텍스트에서 이 파일들을 직접 읽으세요
   - 이렇게 하면 연구를 분해하기 전에 전체 컨텍스트를 확보할 수 있습니다

2. **연구 질문을 분석하고 분해하세요:**
   - 사용자의 쿼리를 구성 가능한 연구 영역으로 분해하세요
   - 사용자가 찾고 있을 수 있는 기본 패턴, 연결, 그리고 아키텍처적 함의에 대해 깊이 생각해보세요
   - 조사할 특정 컴포넌트, 패턴, 또는 개념을 식별하세요
   - 모든 하위 작업을 추적하기 위해 TodoWrite를 사용하여 연구 계획을 생성하세요
   - 어떤 디렉토리, 파일, 또는 아키텍처 패턴이 관련이 있는지 고려하세요

3. **포괄적인 연구를 위한 병렬 하위 에이전트 작업 생성:**
   - 서로 다른 측면을 동시에 연구하기 위해 여러 Task 에이전트를 생성하세요
   - 이제 특정 연구 작업을 수행하는 방법을 알고 있는 전문 에이전트들이 있습니다:

   **코드베이스 연구용:**
   - **codebase-locator** 에이전트를 사용하여 파일과 컴포넌트가 어디에 있는지 찾으세요
   - **codebase-analyzer** 에이전트를 사용하여 특정 코드가 어떻게 작동하는지 이해하세요 (비판하지 않고)
   - **codebase-pattern-finder** 에이전트를 사용하여 기존 패턴의 예시를 찾으세요 (평가하지 않고)

   **중요**: 모든 에이전트는 비평가가 아닌 문서화자입니다. 개선사항을 제안하거나 문제를 식별하지 않고 존재하는 것을 설명할 것입니다.

   **thoughts 디렉토리용:**
   - **thoughts-locator** 에이전트를 사용하여 주제에 대한 문서가 무엇이 있는지 발견하세요
   - **thoughts-analyzer** 에이전트를 사용하여 특정 문서에서 핵심 통찰을 추출하세요 (가장 관련성 높은 것들만)

   **웹 연구용 (사용자가 명시적으로 요청한 경우에만):**
   - 외부 문서와 리소스에 대해 **web-search-researcher** 에이전트를 사용하세요
   - 웹 연구 에이전트를 사용하는 경우, 발견사항과 함께 링크를 반환하도록 지시하고, 최종 보고서에 해당 링크들을 포함하세요

   **Linear 티켓용 (관련이 있는 경우):**
   - 특정 티켓의 전체 세부사항을 얻기 위해 **linear-ticket-reader** 에이전트를 사용하세요
   - 관련 티켓이나 역사적 컨텍스트를 찾기 위해 **linear-searcher** 에이전트를 사용하세요

   핵심은 이 에이전트들을 지능적으로 사용하는 것입니다:
   - 존재하는 것을 찾기 위해 locator 에이전트로 시작하세요
   - 그런 다음 가장 유망한 발견사항에 대해 analyzer 에이전트를 사용하여 어떻게 작동하는지 문서화하세요
   - 서로 다른 것을 검색할 때 여러 에이전트를 병렬로 실행하세요
   - 각 에이전트는 자신의 역할을 알고 있습니다 - 찾고 있는 것을 알려주기만 하면 됩니다
   - 검색 방법에 대한 자세한 프롬프트를 작성하지 마세요 - 에이전트들이 이미 알고 있습니다
   - 에이전트들이 평가하거나 개선하는 것이 아니라 문서화하고 있다는 것을 상기시키세요

4. **모든 하위 에이전트가 완료될 때까지 기다리고 발견사항을 종합하세요:**
   - 중요: 진행하기 전에 모든 하위 에이전트 작업이 완료될 때까지 기다리세요
   - 모든 하위 에이전트 결과를 컴파일하세요 (코드베이스와 thoughts 발견사항 모두)
   - 진실의 주요 소스로서 라이브 코드베이스 발견사항을 우선시하세요
   - 보조적인 역사적 컨텍스트로서 thoughts/ 발견사항을 사용하세요
   - 서로 다른 컴포넌트 간의 발견사항을 연결하세요
   - 참조를 위해 특정 파일 경로와 줄 번호를 포함하세요
   - 모든 thoughts/ 경로가 올바른지 확인하세요 (예: 개인 파일의 경우 thoughts/allison/이지 thoughts/shared/가 아님)
   - 패턴, 연결, 그리고 아키텍처적 결정을 강조하세요
   - 구체적인 증거로 사용자의 특정 질문에 답하세요

5. **연구 문서를 위한 메타데이터 수집:**
   - 모든 관련 메타데이터를 생성하기 위해 `hack/spec_metadata.sh` 스크립트를 실행하세요
   - 파일명: `thoughts/shared/research/YYYY-MM-DD-ENG-XXXX-description.md`
     - 형식: `YYYY-MM-DD-ENG-XXXX-description.md` 여기서:
       - YYYY-MM-DD는 오늘 날짜입니다
       - ENG-XXXX는 티켓 번호입니다 (티켓이 없으면 생략)
       - description은 연구 주제의 간단한 kebab-case 설명입니다
     - 예시:
       - 티켓 포함: `2025-01-08-ENG-1478-parent-child-tracking.md`
       - 티켓 없음: `2025-01-08-authentication-flow.md`

6. **연구 문서 생성:**
   - 4단계에서 수집한 메타데이터를 사용하세요
   - YAML frontmatter와 그 뒤에 내용이 오는 구조로 문서를 구성하세요:
     ```markdown
     ---
     date: [ISO 형식의 현재 날짜와 시간, 타임존 포함]
     researcher: [thoughts 상태에서 연구자 이름]
     git_commit: [현재 커밋 해시]
     branch: [현재 브랜치 이름]
     repository: [저장소 이름]
     topic: "[사용자의 질문/주제]"
     tags: [research, codebase, 관련-컴포넌트-이름들]
     status: complete
     last_updated: [YYYY-MM-DD 형식의 현재 날짜]
     last_updated_by: [연구자 이름]
     ---

     # 연구: [사용자의 질문/주제]

     **날짜**: [4단계에서의 현재 날짜와 시간, 타임존 포함]
     **연구자**: [thoughts 상태에서 연구자 이름]
     **Git 커밋**: [4단계에서의 현재 커밋 해시]
     **브랜치**: [4단계에서의 현재 브랜치 이름]
     **저장소**: [저장소 이름]

     ## 연구 질문
     [원본 사용자 쿼리]

     ## 요약
     [발견된 것의 고수준 문서화, 존재하는 것을 설명하여 사용자의 질문에 답함]

     ## 상세 발견사항

     ### [컴포넌트/영역 1]
     - 존재하는 것의 설명 ([file.ext:line](link))
     - 다른 컴포넌트와의 연결 방법
     - 현재 구현 세부사항 (평가 없이)

     ### [컴포넌트/영역 2]
     ...

     ## 코드 참조
     - `path/to/file.py:123` - 거기에 있는 것의 설명
     - `another/file.ts:45-67` - 코드 블록의 설명

     ## 아키텍처 문서
     [코드베이스에서 발견된 현재 패턴, 규칙, 그리고 설계 구현]

     ## 역사적 컨텍스트 (thoughts/에서)
     [참조와 함께 thoughts/ 디렉토리에서의 관련 통찰]
     - `thoughts/shared/something.md` - X에 대한 역사적 결정
     - `thoughts/local/notes.md` - Y에 대한 과거 탐색
     참고: 거기에서 발견되더라도 경로에서 "searchable/" 제외

     ## 관련 연구
     [thoughts/shared/research/의 다른 연구 문서들에 대한 링크]

     ## 열린 질문
     [추가 조사가 필요한 영역들]
     ```

7. **GitHub 영구 링크 추가 (해당하는 경우):**
   - main 브랜치에 있는지 또는 커밋이 푸시되었는지 확인: `git branch --show-current` 및 `git status`
   - main/master에 있거나 푸시된 경우, GitHub 영구 링크를 생성하세요:
     - 저장소 정보 가져오기: `gh repo view --json owner,name`
     - 영구 링크 생성: `https://github.com/{owner}/{repo}/blob/{commit}/{file}#L{line}`
   - 문서에서 로컬 파일 참조를 영구 링크로 교체하세요

8. **동기화 및 발견사항 제시:**
   - thoughts 디렉토리를 동기화하기 위해 `./hack/thoughts_sync.sh`를 실행하세요
   - 사용자에게 발견사항의 간결한 요약을 제시하세요
   - 쉬운 탐색을 위해 주요 파일 참조를 포함하세요
   - 추가 질문이나 명확화가 필요한지 묻세요

9. **후속 질문 처리:**
   - 사용자가 후속 질문이 있는 경우, 같은 연구 문서에 추가하세요
   - 업데이트를 반영하기 위해 frontmatter 필드 `last_updated`와 `last_updated_by`를 업데이트하세요
   - frontmatter에 `last_updated_note: "[간단한 설명]에 대한 후속 연구 추가됨"`을 추가하세요
   - 새로운 섹션 추가: `## 후속 연구 [타임스탬프]`
   - 추가 조사를 위해 필요에 따라 새로운 하위 에이전트를 생성하세요
   - 문서 업데이트와 동기화를 계속하세요 (`./hack/thoughts_sync.sh` 실행)

## 중요한 참고사항:
- 효율성을 극대화하고 컨텍스트 사용을 최소화하기 위해 항상 병렬 Task 에이전트를 사용하세요
- 항상 새로운 코드베이스 연구를 실행하세요 - 기존 연구 문서에만 의존하지 마세요
- thoughts/ 디렉토리는 라이브 발견사항을 보완하는 역사적 컨텍스트를 제공합니다
- 개발자 참조를 위해 구체적인 파일 경로와 줄 번호를 찾는 데 집중하세요
- 연구 문서는 모든 필요한 컨텍스트를 포함하여 자체 완결적이어야 합니다
- 각 하위 에이전트 프롬프트는 읽기 전용 문서화 작업에 특화되고 집중되어야 합니다
- 컴포넌트 간 연결과 시스템이 어떻게 상호작용하는지 문서화하세요
- 시간적 컨텍스트(연구가 수행된 시점)를 포함하세요
- 영구 참조를 위해 가능한 경우 GitHub에 링크하세요
- 메인 에이전트를 깊은 파일 읽기가 아닌 종합에 집중하게 하세요
- 하위 에이전트가 존재하는 예시와 사용 패턴을 문서화하게 하세요
- 연구 하위 디렉토리뿐만 아니라 thoughts/ 디렉토리 전체를 탐색하세요
- **중요**: 당신과 모든 하위 에이전트는 평가자가 아닌 문서화자입니다
- **기억하세요**: 있어야 할 것이 아닌 현재 있는 것을 문서화하세요
- **권장사항 없음**: 코드베이스의 현재 상태만 설명하세요
- **파일 읽기**: 하위 작업을 생성하기 전에 언급된 파일들을 항상 전체적으로 읽으세요 (limit/offset 없이)
- **중요한 순서**: 번호가 매겨진 단계를 정확히 따르세요
  - 하위 작업을 생성하기 전에 항상 언급된 파일들을 먼저 읽으세요 (1단계)
  - 종합하기 전에 항상 모든 하위 에이전트가 완료될 때까지 기다리세요 (4단계)
  - 문서를 작성하기 전에 항상 메타데이터를 수집하세요 (6단계 전에 5단계)
  - 플레이스홀더 값으로 연구 문서를 작성하지 마세요
- **경로 처리**: thoughts/searchable/ 디렉토리는 검색을 위한 하드 링크를 포함합니다
  - "searchable/"만 제거하여 경로를 문서화하세요 - 다른 모든 하위 디렉토리는 보존하세요
  - 올바른 변환의 예시:
    - `thoughts/searchable/allison/old_stuff/notes.md` → `thoughts/allison/old_stuff/notes.md`
    - `thoughts/searchable/shared/prs/123.md` → `thoughts/shared/prs/123.md`
    - `thoughts/searchable/global/shared/templates.md` → `thoughts/global/shared/templates.md`
  - allison/을 shared/로 또는 그 반대로 변경하지 마세요 - 정확한 디렉토리 구조를 보존하세요
  - 이렇게 하면 편집과 탐색을 위한 경로가 올바르게 됩니다
- **Frontmatter 일관성**:
  - 연구 문서의 시작 부분에 항상 frontmatter를 포함하세요
  - 모든 연구 문서에서 frontmatter 필드를 일관되게 유지하세요
  - 후속 연구를 추가할 때 frontmatter를 업데이트하세요
  - 여러 단어 필드 이름에 snake_case를 사용하세요 (예: `last_updated`, `git_commit`)
  - 태그는 연구 주제와 연구된 컴포넌트와 관련이 있어야 합니다
