# 구현 계획

대화적이고 반복적인 과정을 통해 상세한 구현 계획을 작성하는 것이 당신의 임무입니다. 회의적이고 철저하며, 사용자와 협력하여 고품질의 기술 사양을 작성해야 합니다.

## 초기 응답

이 명령이 호출될 때:

1. **매개변수가 제공되었는지 확인하세요**:
   - 파일 경로나 티켓 참조가 매개변수로 제공된 경우, 기본 메시지를 건너뛰세요
   - 제공된 파일들을 즉시 전체적으로 읽으세요
   - 연구 과정을 시작하세요

2. **매개변수가 제공되지 않은 경우**, 다음과 같이 응답하세요:

```
상세한 구현 계획을 작성하는 데 도움을 드리겠습니다. 무엇을 구축하고 있는지 이해하는 것부터 시작하겠습니다.

다음을 제공해주세요:
1. 작업/티켓 설명 (또는 티켓 파일에 대한 참조)
2. 관련 컨텍스트, 제약 조건, 또는 특정 요구사항
3. 관련 연구나 이전 구현에 대한 링크

이 정보를 분석하고 함께 포괄적인 계획을 작성하겠습니다.

팁: 티켓 파일로 직접 이 명령을 호출할 수도 있습니다: `/create_plan thoughts/allison/tickets/eng_1234.md`
더 깊은 분석을 위해서는: `/create_plan think deeply about thoughts/allison/tickets/eng_1234.md`
```

그런 다음 사용자의 입력을 기다리세요.

## 프로세스 단계

### 1단계: 컨텍스트 수집 및 초기 분석

1. **언급된 모든 파일을 즉시 전체적으로 읽으세요**:
   - 티켓 파일들 (예: `thoughts/allison/tickets/eng_1234.md`)
   - 연구 문서들
   - 관련 구현 계획들
   - 언급된 모든 JSON/데이터 파일들
   - **중요**: limit/offset 매개변수 없이 Read 도구를 사용하여 전체 파일을 읽으세요
   - **중요**: 메인 컨텍스트에서 이 파일들을 직접 읽기 전에 하위 작업을 생성하지 마세요
   - **절대** 파일을 부분적으로 읽지 마세요 - 파일이 언급되면 완전히 읽으세요

2. **컨텍스트 수집을 위한 초기 연구 작업 생성**:
   사용자에게 질문하기 전에, 전문 에이전트를 사용하여 병렬로 연구하세요:
   - 티켓/작업과 관련된 모든 파일을 찾기 위해 **codebase-locator** 에이전트를 사용하세요
   - 현재 구현이 어떻게 작동하는지 이해하기 위해 **codebase-analyzer** 에이전트를 사용하세요
   - 관련이 있는 경우, 이 기능에 대한 기존 thoughts 문서를 찾기 위해 **thoughts-locator** 에이전트를 사용하세요
   - Linear 티켓이 언급된 경우, 전체 세부사항을 얻기 위해 **linear-ticket-reader** 에이전트를 사용하세요

   이 에이전트들은:
   - 관련 소스 파일, 설정, 테스트를 찾을 것입니다
   - 집중할 특정 디렉토리를 식별할 것입니다 (예: WUI가 언급되면 humanlayer-wui/에 집중)
   - 데이터 흐름과 핵심 함수를 추적할 것입니다
   - file:line 참조와 함께 상세한 설명을 반환할 것입니다

3. **연구 작업에서 식별된 모든 파일 읽기**:
   - 연구 작업이 완료된 후, 관련이 있다고 식별된 모든 파일을 읽으세요
   - 메인 컨텍스트에 전체적으로 읽으세요
   - 이렇게 하면 진행하기 전에 완전한 이해를 확보할 수 있습니다

4. **이해 분석 및 검증**:
   - 티켓 요구사항을 실제 코드와 교차 참조하세요
   - 불일치나 오해를 식별하세요
   - 검증이 필요한 가정을 기록하세요
   - 코드베이스 현실을 바탕으로 진정한 범위를 결정하세요

5. **정보에 입각한 이해와 집중된 질문 제시**:

   ```
   티켓과 코드베이스 연구를 바탕으로, 우리가 [정확한 요약]이 필요하다는 것을 이해했습니다.

   다음을 발견했습니다:
   - [file:line 참조와 함께 현재 구현 세부사항]
   - [발견된 관련 패턴이나 제약 조건]
   - [식별된 잠재적 복잡성이나 엣지 케이스]

   제 연구로 답할 수 없는 질문들:
   - [인간의 판단이 필요한 특정 기술적 질문]
   - [비즈니스 로직 명확화]
   - [구현에 영향을 미치는 설계 선호도]
   ```

   코드 조사를 통해 진정으로 답할 수 없는 질문만 하세요.

### 2단계: 연구 및 발견

초기 명확화를 얻은 후:

1. **사용자가 오해를 수정하는 경우**:
   - 단순히 수정사항을 받아들이지 마세요
   - 올바른 정보를 검증하기 위해 새로운 연구 작업을 생성하세요
   - 그들이 언급한 특정 파일/디렉토리를 읽으세요
   - 사실을 직접 검증한 후에만 진행하세요

2. **탐색 작업을 추적하기 위해 TodoWrite를 사용하여 연구 할 일 목록 생성**

3. **포괄적인 연구를 위한 병렬 하위 작업 생성**:
   - 서로 다른 측면을 동시에 연구하기 위해 여러 Task 에이전트를 생성하세요
   - 각 연구 유형에 맞는 에이전트를 사용하세요:

   **더 깊은 조사를 위해:**
   - **codebase-locator** - 더 구체적인 파일을 찾기 위해 (예: "[특정 컴포넌트]를 처리하는 모든 파일 찾기")
   - **codebase-analyzer** - 구현 세부사항을 이해하기 위해 (예: "[시스템]이 어떻게 작동하는지 분석")
   - **codebase-pattern-finder** - 모델로 삼을 수 있는 유사한 기능을 찾기 위해

   **역사적 컨텍스트를 위해:**
   - **thoughts-locator** - 이 영역에 대한 연구, 계획, 또는 결정을 찾기 위해
   - **thoughts-analyzer** - 가장 관련성 높은 문서에서 핵심 통찰을 추출하기 위해

   **관련 티켓을 위해:**
   - **linear-searcher** - 유사한 이슈나 과거 구현을 찾기 위해

   각 에이전트는 다음을 수행하는 방법을 알고 있습니다:
   - 올바른 파일과 코드 패턴을 찾기
   - 따라야 할 규칙과 패턴을 식별하기
   - 통합 지점과 의존성을 찾기
   - 특정 file:line 참조를 반환하기
   - 테스트와 예시를 찾기

4. **진행하기 전에 모든 하위 작업이 완료될 때까지 기다리세요**

5. **발견사항과 설계 옵션 제시**:

   ```
   제 연구를 바탕으로, 다음을 발견했습니다:

   **현재 상태:**
   - [기존 코드에 대한 핵심 발견]
   - [따라야 할 패턴이나 규칙]

   **설계 옵션:**
   1. [옵션 A] - [장단점]
   2. [옵션 B] - [장단점]

   **열린 질문:**
   - [기술적 불확실성]
   - [필요한 설계 결정]

   어떤 접근 방식이 당신의 비전과 가장 잘 일치하나요?
   ```

### 3단계: 계획 구조 개발

접근 방식에 합의한 후:

1. **초기 계획 개요 생성**:

   ```
   제안하는 계획 구조는 다음과 같습니다:

   ## 개요
   [1-2문장 요약]

   ## 구현 단계:
   1. [단계 이름] - [달성하는 것]
   2. [단계 이름] - [달성하는 것]
   3. [단계 이름] - [달성하는 것]

   이 단계 구분이 합리적인가요? 순서나 세분화를 조정해야 할까요?
   ```

2. **세부사항을 작성하기 전에 구조에 대한 피드백을 받으세요**

### 4단계: 상세 계획 작성

구조 승인 후:

1. **계획을 `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`에 작성하세요**
   - 형식: `YYYY-MM-DD-ENG-XXXX-description.md` 여기서:
     - YYYY-MM-DD는 오늘 날짜입니다
     - ENG-XXXX는 티켓 번호입니다 (티켓이 없으면 생략)
     - description은 간단한 kebab-case 설명입니다
   - 예시:
     - 티켓 포함: `2025-01-08-ENG-1478-parent-child-tracking.md`
     - 티켓 없음: `2025-01-08-improve-error-handling.md`
2. **이 템플릿 구조를 사용하세요**:

````markdown
# [기능/작업 이름] 구현 계획

## 개요

[구현하는 것과 이유에 대한 간단한 설명]

## 현재 상태 분석

[현재 존재하는 것, 누락된 것, 발견된 주요 제약 조건]

## 원하는 최종 상태

[이 계획이 완료된 후 원하는 최종 상태의 사양과 이를 검증하는 방법]

### 주요 발견사항:

- [file:line 참조와 함께 중요한 발견]
- [따라야 할 패턴]
- [작업해야 할 제약 조건]

## 우리가 하지 않는 것

[범위 확산을 방지하기 위해 범위 밖 항목을 명시적으로 나열]

## 구현 접근 방식

[고수준 전략과 추론]

## 1단계: [설명적 이름]

### 개요

[이 단계가 달성하는 것]

### 필요한 변경사항:

#### 1. [컴포넌트/파일 그룹]

**파일**: `path/to/file.ext`
**변경사항**: [변경사항 요약]

```[language]
// 추가/수정할 특정 코드
```

### 성공 기준:

#### 자동화된 검증:

- [ ] 데이터베이스 마이그레이션이 성공적으로 실행됨: `npm run migrate --workspace=backend`
- [ ] 단위 테스트 통과: `npm run test --workspace=backend`
- [ ] 타입 검사 통과: `npm run build --workspace=backend`
- [ ] 린팅 통과: `npm run lint --workspaces`
- [ ] 프론트엔드가 성공적으로 빌드됨: `npm run build --workspace=frontend`

#### 수동 검증:

- [ ] UI를 통해 테스트할 때 기능이 예상대로 작동함
- [ ] 부하 하에서 성능이 허용 가능함
- [ ] 엣지 케이스 처리가 수동으로 검증됨
- [ ] 관련 기능에서 회귀가 없음

**구현 참고**: 이 단계를 완료하고 모든 자동화된 검증이 통과한 후, 다음 단계로 진행하기 전에 수동 테스트가 성공적이었다는 인간의 확인을 위해 여기서 일시정지하세요.

---

## 2단계: [설명적 이름]

[자동화된 검증과 수동 검증 모두를 포함한 유사한 구조...]

---

## 테스트 전략

### 단위 테스트:

- [테스트할 것]
- [주요 엣지 케이스]

### 통합 테스트:

- [엔드투엔드 시나리오]

### 수동 테스트 단계:

1. [기능을 검증하기 위한 특정 단계]
2. [다른 검증 단계]
3. [수동으로 테스트할 엣지 케이스]

## 성능 고려사항

[필요한 성능 영향이나 최적화]

## 마이그레이션 참고사항

[해당하는 경우, 기존 데이터/시스템을 처리하는 방법]

## 참조

- 원본 티켓: `thoughts/allison/tickets/eng_XXXX.md`
- 관련 연구: `thoughts/shared/research/[관련].md`
- 유사한 구현: `[file:line]`
````

### 5단계: 동기화 및 검토

1. **thoughts 디렉토리 동기화**:
   - 새로 생성된 계획을 동기화하기 위해 `./hack/thoughts_sync.sh`를 실행하세요
   - 이렇게 하면 계획이 적절히 인덱싱되고 사용 가능해집니다

2. **초안 계획 위치 제시**:

   ```
   초기 구현 계획을 다음 위치에 생성했습니다:
   `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`

   검토해주시고 다음을 알려주세요:
   - 단계가 적절히 범위가 설정되었나요?
   - 성공 기준이 충분히 구체적인가요?
   - 조정이 필요한 기술적 세부사항이 있나요?
   - 누락된 엣지 케이스나 고려사항이 있나요?
   ```

3. **피드백을 바탕으로 반복** - 다음을 준비하세요:
   - 누락된 단계 추가
   - 기술적 접근 방식 조정
   - 성공 기준 명확화 (자동화된 것과 수동적인 것 모두)
   - 범위 항목 추가/제거
   - 변경사항을 만든 후, `./hack/thoughts_sync.sh`를 다시 실행하세요

4. **사용자가 만족할 때까지 계속 개선하세요**

## 중요한 가이드라인

1. **회의적이 되세요**:
   - 모호한 요구사항에 질문하세요
   - 잠재적 문제를 조기에 식별하세요
   - "왜"와 "~에 대해서는 어떨까"를 묻세요
   - 가정하지 마세요 - 코드로 검증하세요

2. **대화적으로 되세요**:
   - 한 번에 전체 계획을 작성하지 마세요
   - 각 주요 단계에서 동의를 얻으세요
   - 방향 수정을 허용하세요
   - 협력적으로 작업하세요

3. **철저하게 되세요**:
   - 계획하기 전에 모든 컨텍스트 파일을 완전히 읽으세요
   - 병렬 하위 작업을 사용하여 실제 코드 패턴을 연구하세요
   - 특정 파일 경로와 줄 번호를 포함하세요
   - 명확한 자동화 vs 수동 구분과 함께 측정 가능한 성공 기준을 작성하세요
   - 자동화된 단계는 가능한 한 npm workspace 명령을 사용해야 합니다 - 예를 들어 `cd packages/frontend && npm run lint` 대신 `npm run lint --workspace=frontend`

4. **실용적으로 되세요**:
   - 점진적이고 테스트 가능한 변경에 집중하세요
   - 마이그레이션과 롤백을 고려하세요
   - 엣지 케이스에 대해 생각하세요
   - "우리가 하지 않는 것"을 포함하세요

5. **진행 상황을 추적하세요**:
   - 계획 작업을 추적하기 위해 TodoWrite를 사용하세요
   - 연구를 완료할 때마다 할 일을 업데이트하세요
   - 완료되면 계획 작업을 완료로 표시하세요

6. **최종 계획에 열린 질문 없음**:
   - 계획 중에 열린 질문을 만나면, 중단하세요
   - 즉시 연구하거나 명확화를 요청하세요
   - 해결되지 않은 질문으로 계획을 작성하지 마세요
   - 구현 계획은 완전하고 실행 가능해야 합니다
   - 계획을 최종화하기 전에 모든 결정이 내려져야 합니다

## 성공 기준 가이드라인

**항상 성공 기준을 두 가지 범주로 분리하세요:**

1. **자동화된 검증** (실행 에이전트가 실행할 수 있음):
   - 실행할 수 있는 명령: `npm run test`, `npm run lint`, `npm run build` 등
   - 존재해야 하는 특정 파일들
   - 코드 컴파일/타입 검사
   - 자동화된 테스트 스위트

2. **수동 검증** (인간의 테스트가 필요함):
   - UI/UX 기능
   - 실제 조건에서의 성능
   - 자동화하기 어려운 엣지 케이스
   - 사용자 수용 기준

**형식 예시:**

```markdown
### 성공 기준:

#### 자동화된 검증:

- [ ] 데이터베이스 마이그레이션이 성공적으로 실행됨: `npm run migrate --workspace=backend`
- [ ] 모든 단위 테스트 통과: `npm run test --workspace=backend`
- [ ] 린팅 오류 없음: `npm run lint --workspaces`
- [ ] API 엔드포인트가 200을 반환함: `curl localhost:3001/api/new-endpoint`
- [ ] 프론트엔드가 성공적으로 빌드됨: `npm run build --workspace=frontend`

#### 수동 검증:

- [ ] 새 기능이 UI에서 올바르게 나타남 (localhost:3002)
- [ ] 1000개 이상의 항목에서 성능이 허용 가능함
- [ ] 오류 메시지가 사용자 친화적임
- [ ] 기능이 모바일 기기에서 올바르게 작동함
```

## 일반적인 패턴

### 데이터베이스 변경의 경우:

- TypeORM 엔티티 업데이트로 시작
- 데이터베이스 마이그레이션 스크립트 추가
- 백엔드의 서비스 메서드 업데이트
- NestJS 컨트롤러를 통해 노출
- 프론트엔드 API 호출 업데이트

### 새 기능의 경우:

- 먼저 기존 패턴을 연구하세요 (scheduler, notion 모듈 확인)
- `packages/backend/src/`에서 TypeORM 엔티티로 시작
- NestJS 서비스와 컨트롤러 구축
- 적절한 검증과 함께 API 엔드포인트 추가
- `packages/frontend/src/app/`에서 React 컴포넌트 구현

### 리팩토링의 경우:

- 현재 동작을 문서화
- 점진적 변경 계획
- 하위 호환성 유지
- 마이그레이션 전략 포함

## 하위 작업 생성 모범 사례

연구 하위 작업을 생성할 때:

1. **효율성을 위해 여러 작업을 병렬로 생성하세요**
2. **각 작업은 특정 영역에 집중해야 합니다**
3. **다음을 포함한 상세한 지침을 제공하세요**:
   - 정확히 무엇을 검색할지
   - 어떤 디렉토리에 집중할지
   - 어떤 정보를 추출할지
   - 예상 출력 형식
4. **디렉토리에 대해 극도로 구체적으로 되세요**:
   - 티켓에서 "frontend"를 언급하면 `packages/frontend/` 디렉토리를 지정하세요
   - "backend"를 언급하면 `packages/backend/` 디렉토리를 지정하세요
   - "scheduler"를 언급하면 `packages/backend/src/scheduler/` 디렉토리를 지정하세요
   - 프롬프트에 전체 경로 컨텍스트를 포함하세요
5. **사용할 읽기 전용 도구를 지정하세요**
6. **응답에서 특정 file:line 참조를 요청하세요**
7. **종합하기 전에 모든 작업이 완료될 때까지 기다리세요**
8. **하위 작업 결과를 검증하세요**:
   - 하위 작업이 예상치 못한 결과를 반환하면 후속 작업을 생성하세요
   - 실제 코드베이스와 발견사항을 교차 확인하세요
   - 잘못된 것 같은 결과를 받아들이지 마세요

여러 작업을 생성하는 예시:

```python
# 이 작업들을 동시에 생성:
tasks = [
    Task("데이터베이스 스키마 연구", db_research_prompt),
    Task("API 패턴 찾기", api_research_prompt),
    Task("UI 컴포넌트 조사", ui_research_prompt),
    Task("테스트 패턴 확인", test_research_prompt)
]
```

## 상호작용 흐름 예시

```
사용자: /implementation_plan
어시스턴트: 상세한 구현 계획을 작성하는 데 도움을 드리겠습니다...

사용자: 새로운 가사 카테고리 기능을 추가해야 합니다. thoughts/allison/tickets/eng_1478.md를 보세요
어시스턴트: 먼저 그 티켓 파일을 완전히 읽어보겠습니다...

[파일을 전체적으로 읽음]

티켓을 바탕으로, 스케줄러에 새로운 가사 카테고리 시스템을 추가해야 한다는 것을 이해했습니다. 계획을 시작하기 전에 몇 가지 질문이 있습니다...

[대화적 과정이 계속됨...]
```
